#include <Rcpp.h>
#include <R.h>
#include <Rinternals.h>
#include <iostream>
#include <Rmath.h>
#include <math.h>
#include <vector>
#include "general_resources.h"

//Enable C++11
// [[Rcpp::plugins(cpp11)]]

using namespace Rcpp ;

std::vector<std::vector<int> > swap_mult (std::vector<std::vector<int> > bin_chains, int m) ;
std::vector<std::vector<std::vector<int> > > multiple_metropolis (IntegerMatrix bin_chains, int m, int b) ;
std::vector<std::vector<std::vector<int> > > n_counts_multiple (IntegerMatrix bin_chains, int n_chain_uniques) ;

long double u6_test_stat (IntegerMatrix bin_chains, int n_chain_uniques, int n_mult_chains, int length_of_chains) ;
long double multiple_chi_sq_test_stat (std::vector<std::vector<int> > bin_chains, int n_chain_uniques) ;
bool multiple_indicate_run (std::vector<int> binChain, int p, int i) ;
long double multiple_run_test_stat (std::vector<std::vector<int> > bin_chains, int p) ;

NumericVector u6_test_stat_array (std::vector<std::vector<std::vector<int> > > bin_chains, int n_chain_uniques) ;
NumericVector multiple_chi_sq_test_stat_array (std::vector<std::vector<std::vector<int> > > bin_chains, int n_chain_uniques) ;
NumericVector multiple_run_test_stat_array (std::vector<std::vector<std::vector<int> > > bin_chains, int p) ;

//' Swap elements of multiple binary chains
//'
//' \code{swap_mult} is used to swap elements of multiple binary chains if doing
//' so maintains the same number of transitions between the two states of those
//' chains.
//'
//' \code{swap_mult} works by taking a two dimensional integer vector
//' \code{bin_chains} and \code{m}, a number of times to attempt swaps. It
//' generates random integers which are valid indices of the two dimensional
//' vector \code{bin_chains} and tries to swap the elements of the vector at
//' the indices that it generates, only doing so if this preserves the total
//' number of transitions between states. After attempting \code{m} swaps,
//' \code{swap_mult} returns the new, freshly swapped two dimensional vector of
//' binary chains.
//'
//' @param bin_chains A two dimensional integer vector with binary values.
//' @param m A positive nonzero integer value for the attempted number of swaps
//' to attempt on \code{bin_chains}.
// [[Rcpp::export]]
std::vector<std::vector<int> > swap_mult (std::vector<std::vector<int> > bin_chains, int m) {
  int n_col = bin_chains[0].size() ;
  int n_row = bin_chains.size() ;
  for (int i = 0 ; i < m ; i++) {
    int case_var = ceil(unif_rand() * 3) ;
    int a = ceil(unif_rand() * (n_col - 2)) ;
    int b = ceil(unif_rand() * (n_col - 2)) ;
    int c = floor(unif_rand() * n_row) ;
    int d = floor(unif_rand() * n_row) ;
    int maxi = std::max(a, b) ;
    int mini = std::min(a, b) ;
    if (case_var == 1) {
      if (abs(a - b) > 1 and bin_chains[c][a - 1] + bin_chains[c][a + 1] == bin_chains[c][b - 1] + bin_chains[c][b + 1]) {
        int xac = bin_chains[c][a] ;
        bin_chains[c][a] = bin_chains[c][b] ;
        bin_chains[c][b] = xac ;
      }
      else if (abs(a - b) == 1 and bin_chains[c][mini - 1] == bin_chains[c][maxi + 1]) {
        int xac = bin_chains[c][a] ;
        bin_chains[c][a] = bin_chains[c][b] ;
        bin_chains[c][b] = xac ;
      }
    }
    else if (case_var == 2) {
      if (bin_chains[c][a - 1] + bin_chains[c][a + 1] == bin_chains[d][b - 1] + bin_chains[d][b + 1]) {
        int xac = bin_chains[c][a] ;
        bin_chains[c][a] = bin_chains[d][b] ;
        bin_chains[d][b] = xac ;
      }
    }
    else if (case_var == 3) {
      if (bin_chains[c][n_col - 1] == bin_chains[d][n_col - 1]) {
        int xnColc = bin_chains[c][n_col] ;
        bin_chains[c][n_col] = bin_chains[d][n_col] ;
        bin_chains[d][n_col] = xnColc ;
      }
    }
  }
  return bin_chains ;
}

//' Generate independent data from a set of binary chains.
//'
//' \code{multiple_metropolis} takes a set of binary chains of data in the form of an
//' integer matrix and returns a three dimensional integer vector with
//' with the first entry of the first dimension filled with the original set
//' of binary chains and the rest filled with independent chains generated by
//' \code{multiple_metropolis}.
//'
//' \code{multiple_metropolis} works by taking a supplied set of binary chains
//' \code{bin_chains} and attempting a number \code{m} swaps on entries of those
//' chains, only swapping if doing so maintains the number of transitions
//' between states that existed in the initial set of chains \code{bin_chains}.
//' After it does this, it repeats the process on the newly generated set of
//' binary chains of data \code{b} times, each time saving the new set of chains
//' in a three dimensional vector of data. The first entry of the first
//' dimension of this vector is used to store the original set of binary chains
//' \code{bin_chains}.
//'
//' @param bin_chains An integer matrix whose rows represent separate binary
//' chains of data.
//' @param m An integer value representing the number of swaps to be attempted.
//' @param b An integer value representing the number of new sets of data to be
//' generated.
//' @export
//' @useDynLib maRkov
// [[Rcpp::export]]
std::vector<std::vector<std::vector<int> > > multiple_metropolis (IntegerMatrix bin_chains, int m, int b) {
  std::vector<std::vector<std::vector<int> > > metropolis ;
  std::vector<std::vector<int> > backwards_bin_chain ;
  std::vector<std::vector<int> > temp_bin_chain ;
  std::vector<std::vector<int> > converted_bin_chain ;
  int n_row = bin_chains.nrow() ;
  int n_col = bin_chains.ncol() ;
  metropolis.resize(b + 1) ;
  for (int i = 0 ; i < b + 1 ; i++) {
    metropolis[i].resize(n_row) ;
    for (int j = 0 ; j < n_row ; j++) {
      metropolis[i][j].resize(n_col) ;
    }
  }
  backwards_bin_chain.resize(n_row) ;
  temp_bin_chain.resize(n_row) ;
  converted_bin_chain.resize(n_row) ;
  for (int k = 0 ; k < n_row ; k++) {
    backwards_bin_chain[k].resize(n_col) ;
    temp_bin_chain[k].resize(n_col) ;
    converted_bin_chain[k].resize(n_col) ;
  }
  for (int l = 0 ; l < n_row ; l++) {
    for (int n = 0 ; n < n_col ; n++) {
      metropolis[0][l][n] = bin_chains(l, n) ;
      converted_bin_chain[l][n] = bin_chains(l, n) ;
    }
  }
  backwards_bin_chain = swap_mult(converted_bin_chain, m) ;

  for (int x = 1 ; x < b + 1 ; x++) {
    temp_bin_chain = swap_mult(backwards_bin_chain, m) ;
    for (int y = 0 ; y < n_row ; y++) {
      for (int z = 0 ; z < n_col ; z++) {
        metropolis[x][y][z] = temp_bin_chain[y][z] ;
      }
    }
  }
  return metropolis ;
}

//' Second order transition counts for multiple binary chains.
//'
//' \code{n_counts_multiple} counts the number of second order transitions in
//' a integer matrix whose rows represent individual binary chains. It returns
//' a three dimensional vector whose indices represent the type of transition,
//' and whose values represent the number of times that each transition occurs
//' in the set of chains.
//'
//' @param bin_chains A two dimensional integer vector, each of whose rows
//' represents a single binary chain of data.
//' @param n_chain_uniques The number of unique values in the set of chains
//' \code{bin_chains}, represented as an integer value.
// [[Rcpp::export]]
std::vector<std::vector<std::vector<int> > > n_counts_multiple (std::vector<std::vector<int> > bin_chains, int n_chain_uniques) {
  std::vector<std::vector<std::vector<int> > > n ;

  n.resize(n_chain_uniques) ;
  for (int i = 0; i < n_chain_uniques ; ++i) {
    n[i].resize(n_chain_uniques) ;

    for (int j = 0; j < n_chain_uniques; ++j)
      n[i][j].resize(bin_chains.size()) ;
  }

  for (int i = 0 ; i < (bin_chains.size()) ; i++) {
    for (int j = 0 ; j < (bin_chains[1].size() - 1) ; j++) {
      for (int k = 0 ; k < n_chain_uniques ; k++) {
        for (int l = 0 ; l < n_chain_uniques ; l++) {
          if (bin_chains[i][j] == k and bin_chains[i][j + 1] == l) {
            n[k][l][i] = n[k][l][i] + 1 ;
          }
        }
      }
    }
  }

  return n ;
}

//' Calculate the likelihood ratio test statistic for a set of binary chains of
//' data.
//'
//' \code{u6_test_stat} takes a two dimensional integer vector \code{bin_chains}
//' in which each row represents a single binary chain of data, and calculates
//' a likelihood ratio test statistic for the entire set.
//'
//' @param bin_chains A two dimensional integer vector where each row is a
//' separate binary chain of data.
//' @param n_chain_uniques An integer value representing the number of unique
//' elements in the set of chains \code{bin_chains}.
// [[Rcpp::export]]
long double u6_test_stat (std::vector<std::vector<int> > bin_chains, int n_chain_uniques) {
  std::vector<std::vector<std::vector<int> > > n = n_counts_multiple(bin_chains, n_chain_uniques) ;
  long double test_stat = 0 ;

  int dim_i = n.size() ;
  int dim_j = n[0].size() ;
  int dim_k = n[0][0].size() ;

  for (int i = 0 ; i < dim_i ; i++) {
    for (int j = 0 ; j < dim_j ; j++) {
      for (int k = 0 ; k < dim_k  ; k++) {
        if (n[i][j][k] != 0) {
          test_stat = test_stat + (n[i][j][k] * (log(n[i][j][k]) - log(j_dim_sum(n, i, k)) - log(k_dim_sum(n, i, j)) + log(jk_dim_sum(n, i)))) ;
        }
        else {
          test_stat = test_stat ;
        }
      }
    }
  }
  test_stat = test_stat * 2 ;
  return test_stat ;
}

//' Calculate the Pearson's chi square test statistic for a set of binary chains
//' of data.
//'
//' \code{multiple_chi_sq_test_stat} takes a two dimensional integer vector
//' \code{bin_chains} in which each row represents a single binary chain of data,
//' and calculates a Pearson's chi square test statistic for the entire set.
//'
//' @param bin_chains A two dimensional integer vector where each row is a
//' separate binary chain of data.
//' @param n_chain_uniques An integer value representing the number of unique
//' elements in the set of chains \code{bin_chains}.
// [[Rcpp::export]]
long double multiple_chi_sq_test_stat (std::vector<std::vector<int> > bin_chains, int n_chain_uniques) {
  std::vector<std::vector<std::vector<int> > > n = n_counts_multiple(bin_chains, n_chain_uniques) ;
  long double test_stat = 0 ;

  int dim_i = n.size() ;
  int dim_j = n[0].size() ;
  int dim_k = n[0][0].size() ;

  for (int i = 0 ; i < dim_i ; i++) {
    for (int j = 0 ; j < dim_j ; j++) {
      for (int k = 0 ; k < dim_k  ; k++) {
        if (n[i][j][k] == 0 or k_dim_sum(n, i, j) * j_dim_sum(n, i, k) == 0) {
          test_stat = test_stat ;
        }
        else {
          test_stat = test_stat + (pow((n[i][j][k] - ((k_dim_sum(n, i, j) / 1.0 * j_dim_sum(n, i, k) / 1.0) / (jk_dim_sum(n, i) / 1.0))), 2) / ((k_dim_sum(n, i, j) / 1.0 * j_dim_sum(n, i, k) / 1.0) / (jk_dim_sum(n, i) / 1.0))) ;
        }
      }
    }
  }
  return test_stat ;
}

//' Indicate whether or not a run of a certain length exists starting at a
//' certain point.
//'
//' \code{multiple_indicate_run} takes a single binary chain \code{binChain}, a
//' valid index of that chain \code{i}, and a length of run \code{p} and tests
//' whether or not a run of that length starts at index \code{i}.
//'
//' @param binChain A one dimensional integer vector representing a binary chain
//' of data.
//' @param p An integer representing the length of run to test for.
//' @param i An integer representing a valid index of \code{binChain}.
//[[Rcpp::export]]
bool multiple_indicate_run (std::vector<int> binChain, int p, int i) {
  for (int k = 0 ; k < p ; k++) {
    if (binChain[i + k] != 1) {
      return FALSE ;
    }
  }
  return TRUE ;
}

//' Calculate the run test statistic for a set of binary chains of data and a
//' run of a certain length.
//'
//' \code{multiple_run_test_stat} takes a two dimensional integer vector
//' \code{bin_chains} in which each row represents a single binary chain of data,
//' and calculates a run test statistic for a run of length \code{p} for the
//' entire set.
//'
//' @param bin_chains A two dimensional integer vector where each row is a
//' separate binary chain of data.
//' @param p An integer value representing the length of run to test for.
//[[Rcpp::export]]
long double multiple_run_test_stat (std::vector<std::vector<int> > bin_chains, int p) {
  int n_row = bin_chains.size() ;
  int n_col = bin_chains[0].size() ;
  long double test_stat = 0 ;
  for (int i = 0 ; i < n_row ; i++) {
    for (int j = 0 ; j < n_col - p ; j++) {
      if (multiple_indicate_run(bin_chains[i], p, j)) {
        test_stat = test_stat + 1 ;
      }
    }
  }
  return test_stat ;
}

//' Calculate likelihood ratio test statistics for many sets of binary chains of
//' data.
//'
//' \code{u6_test_stat_array} takes a three dimensional vector containing multiple
//' sets of binary chains of data, and returns a numeric vector with entries
//' corresponding to the likelihood ratio test statistics of each set of binary
//' chains of data.
//'
//' @param bin_chains A three dimensional vector containing sets of chains of
//' binary data.
//' @param n_chain_uniques An integer value representing the number of unique
//' elements in the set of chains \code{bin_chains}.
//' @export
//' @useDynLib maRkov
// [[Rcpp::export]]
NumericVector u6_test_stat_array (std::vector<std::vector<std::vector<int> > > bin_chains, int n_chain_uniques) {
  int size = bin_chains.size() ;
  NumericVector out(size) ;
  for (int i = 0 ; i < size ; i++) {
    out[i] = u6_test_stat(bin_chains[i], n_chain_uniques) ;
  }
  return out ;
}

//' Calculate Pearson's chi square test statistics for many sets of binary
//' chains of data.
//'
//' \code{multiple_chi_sq_test_stat_array} takes a three dimensional vector
//' containing multiple sets of binary chains of data, and returns a numeric
//' vector with entries corresponding to the Pearson's chi square test
//' statistics of each set of binary chains of data.
//'
//' @param bin_chains A three dimensional vector containing sets of chains of
//' binary data.
//' @param n_chain_uniques An integer value representing the number of unique
//' elements in the set of chains \code{bin_chains}.
//' @export
//' @useDynLib maRkov
//[[Rcpp::export]]
NumericVector multiple_chi_sq_test_stat_array (std::vector<std::vector<std::vector<int> > > bin_chains, int n_chain_uniques) {
  int size = bin_chains.size() ;
  NumericVector out(size) ;
  for (int i = 0 ; i < size ; i++) {
    out[i] = multiple_chi_sq_test_stat(bin_chains[i], n_chain_uniques) ;
  }
  return out ;
}

//' Calculate run test statistics for many sets of chains of binary data.
//'
//' \code{multiple_run_test_stat_array} takes a three dimensional integer vector
//' containing multiple sets of binary chains of data, and returns a numeric
//' vector with entries corresponding to the run test statistics for runs of
//' length p for each set of binary chains of data.
//'
//' @param bin_chains A three dimensional integer vector containing sets of
//' chains of binary data.
//' @param p An integer representing the length of run to test for.
//' @export
//' @useDynLib maRkov
//[[Rcpp::export]]
NumericVector multiple_run_test_stat_array (std::vector<std::vector<std::vector<int> > > bin_chains, int p) {
  int n = bin_chains.size() ;
  NumericVector out(n) ;
  for (int i = 0 ; i < n ; i++) {
    out[i] = multiple_run_test_stat(bin_chains[i], p) ;
  }
  return out ;
}
