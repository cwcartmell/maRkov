#' Perform goodness-of-fit tests on a single binary chain.
#'
#' \code{single.binary.test} is used to preform goodness-of-fit tests on single
#' binary chains of data to see if a Markov chain model is appropriate.
#'
#' \code{single.binary.test} works by taking the supplied \code{binary.chain}
#' parameter, counting the transitions between different elements, and then
#' generating \code{n} new chains with the same number of transitions. It
#' generates these new chains by attempting to swap random elements of the chain
#' \code{swaps} times, only doing so if the attempted swap preserves the number
#' of transitions between the two unique elements of the chain.
#' \code{single.binary.test} then saves the chain generated by this process,
#' then preforms a number of swaps equivalent to the value of \code{swaps} on
#' that chain again, then recording the result in a matrix of new data.
#' \code{single.binary.test} does this \code{n} times to generate the \code{n}
#' new chains. These new chains are effectively independent of the original one.
#'
#' Once \code{single.binary.test} has generated new data, it preforms various
#' tests on that data. Included in the function are the likelihood ratio test,
#' the Pearson's chi square test, and a run test for a run of length specified
#' by the argument \code{run}.
#'
#' @param binary.chain A one dimensional vector with two unique values.
#' @param swaps A positive nonzero integer value for the number of swaps to be
#' attempted on the chain. Larger numbers will tend to yield "more independent"
#' data. Generally, the number of swaps should be far greater than the length
#' of \code{binary.chain}.
#' @param n A positive nonzero integer value representing the number of new
#' chains to be generated.
#' @param run The length of run to test for if one is interested in run test
#' statistics.
#' @param tiles The number of chains to be represented in the tile plot when
#' one plots objects generated by \code{single.binary.test}
#' @param bins The number of bins to be displayed in histograms of test
#' statistics when one plots objects generated by \code{single.binary.test}.
#'
#' @examples
#' data <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0)
#' foo <- single.binary.test(binary.chain = data, swaps = 10000, n = 10000,
#' run = 4, tiles = 32, bins = 100)
#'
#' @return \code{single.binary.test} returns a list of \link{class}
#' \code{"single.binary.test"} with the following elements:
#'
#' \code{data}, a matrix of data with \code{binary.chain} in the first row, and
#' the generated n rows of data in the following columns.
#'
#' \code{test.stats.lrt}, a vector of likelihood ratio test statistics for each
#' row of data in \code{data}.
#'
#' \code{test.stats.chisq},  a vector of Pearson's chi square test statistics
#' for each row of data in \code{data}.
#'
#' \code{test.stats.run},  a vector of run test statistics for a run of length
#' \code{run} for each row of data in \code{data}.
#'
#' \code{p.value.lrt}, the p-value of \code{binary.chain} calculated exactly
#' from the distribution of \code{test.stats.lrt}
#'
#' \code{p.value.chisq}, the p-value of \code{binary.chain} calculated exactly
#' from the distribution of \code{test.stats.chisq}
#'
#' \code{p.value.run}, the p-value of \code{binary.chain} calculated exactly
#' from the distribution of \code{test.stats.run}
#'
#' \code{call}, the function call.
#'
#' \code{run}, the length of run specified in the function call.
#'
#' \code{tiles}, the number of tiles specified in the function call.
#'
#' \code{bins}, the number of bins specified in the function call.
#' @export
single.binary.test <- function(binary.chain, swaps = 1000, n = 1000, run = 4,
                               tiles = 30, bins = 30) {
    # Block checks tiles input against b.

    if (tiles > n + 1) {
        print("Warning: you asked for more tiles than generated data.")
        tiles <- min(n + 1, 30)
    }
    # End Block

    # Block checks binary chain, alters it if necessary.

    if (check.false.binary(binary.chain) == FALSE) {
        print("Error: the argument binary.chain must be a set of binary data")
        return(NULL)
    }

    if (check.true.binary(binary.chain) == FALSE) {
        binary.chain <- alter.to.true.binary(binary.chain)
    }

    # End block.
    # Block generates data, p-values, returns list of all info with class
    # 'single.binary.test'.

    n.chain.uniques <- length(unique(binary.chain))
    data <- metropolis(binary.chain, swaps, n)
    test.stats.lrt <- u1TestStatArray(data, n.chain.uniques)
    test.stats.chisq <- chiSqTestStatArray(data, n.chain.uniques)
    test.stats.run <- runTestStatArray(data, run)

    p.value.lrt <- vecGreaterThan(test.stats.lrt)/(n + 1)
    p.value.chisq <- vecGreaterThan(test.stats.chisq)/(n + 1)
    p.value.run <- vecGreaterThan(test.stats.run)/(n + 1)

    out <- list(data =  matrix(unlist(data), ncol = length(binary.chain),
                               byrow = TRUE),
                test.stats.lrt = test.stats.lrt,
                test.stats.chisq = test.stats.chisq,
                test.stats.run = test.stats.run,
                p.value.lrt = p.value.lrt,
                p.value.chisq = p.value.chisq,
                p.value.run = p.value.run,
                call = match.call(),
                run = run,
                tiles = tiles,
                bins = bins)
    class(out) <- "single.binary.test"
    return(out)
    # End block.
}
