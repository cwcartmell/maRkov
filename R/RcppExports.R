# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Sum all the values in the first dimension of a three dimensional integer
#' vector.
#'
#' \code{iDimSum} takes a three dimensional integer vector, fixes the values
#' of the second and thrid dimensions, and then sums the values of all the
#' entires in the vector with those two values for its second and third
#' dimensions.
#'
#' @param n A three dimensional integer vector.
#' @param j An integer that is a valid index of the second dimension of
#' \code{n}.
#' @param k An integer that is a valid index of the third dimension of
#' \code{n}.
iDimSum <- function(n, j, k) {
    .Call('maRkov_iDimSum', PACKAGE = 'maRkov', n, j, k)
}

#' Sum all the values in the second dimension of a three dimensional integer
#' vector.
#'
#' \code{jDimSum} takes a three dimensional integer vector, fixes the values
#' of the first and thrid dimensions, and then sums the values of all the
#' entires in the vector with those two values for its first and third
#' dimensions.
#'
#' @param n A three dimensional integer vector.
#' @param i An integer that is a valid index of the first dimension of
#' \code{n}.
#' @param k An integer that is a valid index of the third dimension of
#' \code{n}.
jDimSum <- function(n, i, k) {
    .Call('maRkov_jDimSum', PACKAGE = 'maRkov', n, i, k)
}

#' Sum all the values in the third dimension of a three dimensional integer
#' vector.
#'
#' \code{kDimSum} takes a three dimensional integer vector, fixes the values
#' of the first and second dimensions, and then sums the values of all the
#' entires in the vector with those two values for its first and second
#' dimensions.
#'
#' @param n A three dimensional integer vector.
#' @param i An integer that is a valid index of the first dimension of
#' \code{n}.
#' @param j An integer that is a valid index of the second dimension of
#' \code{n}.
kDimSum <- function(n, i, j) {
    .Call('maRkov_kDimSum', PACKAGE = 'maRkov', n, i, j)
}

#' Sum all the values in the first and third dimensions of a three dimensional
#' integer vector.
#'
#' \code{ikDimSum} takes a three dimensional integer vector, fixes the value
#' of the second dimension, and then sums the values of all the
#' entires in the vector with that value for its second dimension.
#'
#' @param n A three dimensional integer vector.
#' @param j An integer that is a valid index of the second dimension of
#' \code{n}.
ikDimSum <- function(n, j) {
    .Call('maRkov_ikDimSum', PACKAGE = 'maRkov', n, j)
}

#' Sum all the values in the second and third dimensions of a three dimensional
#' integer vector.
#'
#' \code{ikDimSum} takes a three dimensional integer vector, fixes the value
#' of the first dimension, and then sums the values of all the
#' entires in the vector with that value for its first dimension.
#'
#' @param n A three dimensional integer vector.
#' @param i An integer that is a valid index of the first dimension of
#' \code{n}.
jkDimSum <- function(n, i) {
    .Call('maRkov_jkDimSum', PACKAGE = 'maRkov', n, i)
}

#' Find the number of entries in a vector greater or equal to the value of the
#' first entry.
#'
#' \code{vecGreaterThan} counts the number of entries in a numberic vector
#' \code{testStats} whose values are greater than that of the value of the
#' first element of the vector.
#'
#' @param testStats A one dimensional numeric vector.
#' @export
#' @useDynLib maRkov
vecGreaterThan <- function(testStats) {
    .Call('maRkov_vecGreaterThan', PACKAGE = 'maRkov', testStats)
}

#' Generate a random indice of a vector
#'
#' \code{rUnifInt} takes a one dimensional vector and randomly generates a
#' valid index of that vector from the discrete uniform distribution. It does
#' not return either the first or last indice.
#'
#' \code{rUnifInt} works by taking the length of a supplied R integer vector,
#' subtracting two from it, and multiplying it by a random number from the
#' uniform distribution on the interval (0, 1). it then rounds this number up
#' to the nearest integer and returns it.
#'
#' @param binChain A single binary chain in the form of an integer vector.
rUnifInt <- function(binChain) {
    .Call('maRkov_rUnifInt', PACKAGE = 'maRkov', binChain)
}

#' Swap elements of multiple binary chains
#'
#' \code{swapMult} is used to swap elements of multiple binary chains if doing
#' so maintains the same number of transitions between the two states of those
#' chains.
#'
#' \code{swapMult} works by taking a two dimensional integer vector
#' \code{binChains} and \code{m}, a number of times to attempt swaps. It
#' generates random integers which are valid indicies of the two dimensional
#' vector \code{binChains} and tries to swap the elements of the vector at
#' the indicies that it generates, only doing so if this preserves the total
#' number of transitions between states. After attempting \code{m} swaps,
#' \code{swapMult} returns the new, freshly swapped two dimensional vector of
#' binary chains.
#'
#' @param binChains A two dimensional integer vector with binary values.
#' @param m A positive nonzero integer value for the attempted number of swaps
#' to attempt on \code{binChains}.
swapMult <- function(binChains, m) {
    .Call('maRkov_swapMult', PACKAGE = 'maRkov', binChains, m)
}

#' Generate independent data from a set of binary chains.
#'
#' \code{u6Metropolis} takes a set of binary chains of data in the form of an
#' integer matrix and returns a three dimensional integer vector with
#' with the first entry of the first dimension filled with the original set
#' of binary chains and the rest filled with independent chains generated by
#' \code{u6Metropolis}.
#'
#' \code{u6Metropolis} works by taking a supplied set of binary chains
#' \code{binChains} and attempting a number \code{m} swaps on entries of those
#' chains, only swapping if doing so maintains the number of transitions
#' between states that existed in the initial set of chains \code{binChains}.
#' After it does this, it repeats the process on the newly generated set of
#' binary chains of data \code{b} times, each time saving the new set of chains
#' in a three dimensional vector of data. The first entry of the first
#' dimension of this vector is used to store the original set of binary chains
#' \code{binChains}.
#'
#' @param binChains An integer matrix whose rows represent seperate binary
#' chains of data.
#' @param m An integer value representing the number of swaps to be attempted.
#' @param b An integer value representing the number of new sets of data to be
#' generated.
#' @export
#' @useDynLib maRkov
u6Metropolis <- function(binChains, m, b) {
    .Call('maRkov_u6Metropolis', PACKAGE = 'maRkov', binChains, m, b)
}

#' Second order transition counts for multiple binary chains.
#'
#' \code{nCountsMultiple} counts the number of second order transitions in
#' a integer matrix whose rows represent individual binary chains. It returns
#' a three dimensional vector whose indicies represent the type of transition,
#' and whose values represent the number of times that each transition occurs
#' in the set of chains.
#'
#' @param binChains A two dimensional integer vector, each of whose rows
#' represents a single binary chain of data.
#' @param nChainUniques The number of unique values in the set of chains
#' \code{binChains}, represented as an integer value.
nCountsMultiple <- function(binChains, nChainUniques) {
    .Call('maRkov_nCountsMultiple', PACKAGE = 'maRkov', binChains, nChainUniques)
}

#' Calculate the liklihood ratio test statistic for a set of binary chains of
#' data.
#'
#' \code{u6TestStat} takes a two dimensional integer vector \code{binChains}
#' in which each row represents a single binary chain of data, and calculates
#' a liklihood ratio test statistic for the entire set.
#'
#' @param binChains A two dimensional integer vector where each row is a
#' seperate binary chain of data.
#' @param nChainUniques An integer value representing the number of unique
#' elements in the set of chains \code{binChains}.
u6TestStat <- function(binChains, nChainUniques) {
    .Call('maRkov_u6TestStat', PACKAGE = 'maRkov', binChains, nChainUniques)
}

#' Calculate the Pearson's chi square test statistic for a set of binary chains
#' of data.
#'
#' \code{multipleChiSqTestStat} takes a two dimensional integer vector
#' \code{binChains} in which each row represents a single binary chain of data,
#' and calculates a Pearson's chi square test statistic for the entire set.
#'
#' @param binChains A two dimensional integer vector where each row is a
#' seperate binary chain of data.
#' @param nChainUniques An integer value representing the number of unique
#' elements in the set of chains \code{binChains}.
multipleChiSqTestStat <- function(binChains, nChainUniques) {
    .Call('maRkov_multipleChiSqTestStat', PACKAGE = 'maRkov', binChains, nChainUniques)
}

#' Indicate whether or not a run of a certain length exists starting at a
#' certain point.
#'
#' \code{multipleIndicateRun} takes a single binary chain \code{binChain}, a
#' valid index of that chain \code{i}, and a length of run \code{p} and tests
#' whether or not a run of that length starts at index \code{i}.
#'
#' @param binChain A one dimensional integer vector representing a binary chain
#' of data.
#' @param p An integer representing the length of run to test for.
#' @param i An integer representing a valid index of \code{binChain}.
multipleIndicateRun <- function(binChain, p, i) {
    .Call('maRkov_multipleIndicateRun', PACKAGE = 'maRkov', binChain, p, i)
}

#' Calculate the run test statistic for a set of binary chains of data and a
#' run of a certain length.
#'
#' \code{multipleRunTestStat} takes a two dimensional integer vector
#' \code{binChains} in which each row represents a single binary chain of data,
#' and calculates a run test statistic for a run of length \code{p} for the
#' entire set.
#'
#' @param binChains A two dimensional integer vector where each row is a
#' seperate binary chain of data.
#' @param p An integer value representing the length of run to test for.
multipleRunTestStat <- function(binChains, p) {
    .Call('maRkov_multipleRunTestStat', PACKAGE = 'maRkov', binChains, p)
}

#' Calculate liklihood ratio test statistics for many sets of binary chains of
#' data.
#'
#' \code{u6TestStatArray} takes a three dimensional vector containing multiple
#' sets of binary chains of data, and returns a numeric vector with entires
#' corresponding to the liklihood ratio test statistics of each set of binary
#' chains of data.
#'
#' @param binChains A three dimensional vector containing sets of chains of
#' binary data.
#' @param nChainUniques An integer value representing the number of unique
#' elements in the set of chains \code{binChains}.
#' @export
#' @useDynLib maRkov
u6TestStatArray <- function(binChains, nChainUniques) {
    .Call('maRkov_u6TestStatArray', PACKAGE = 'maRkov', binChains, nChainUniques)
}

#' Calculate Pearson's chi square test statistics for many sets of binary
#' chains of data.
#'
#' \code{multipleChiSqTestStatArray} takes a three dimensional vector
#' containing multiple sets of binary chains of data, and returns a numeric
#' vector with entires corresponding to the Pearson's chi square test
#' statistics of each set of binary chains of data.
#'
#' @param binChains A three dimensional vector containing sets of chains of
#' binary data.
#' @param nChainUniques An integer value representing the number of unique
#' elements in the set of chains \code{binChains}.
#' @export
#' @useDynLib maRkov
multipleChiSqTestStatArray <- function(binChains, nChainUniques) {
    .Call('maRkov_multipleChiSqTestStatArray', PACKAGE = 'maRkov', binChains, nChainUniques)
}

#' Calculate run test statistics for many sets of chains of binary data.
#'
#' \code{multipleRunTestStatArray} takes a three dimensional integer vector
#' containing multiple sets of binary chains of data, and returns a numeric
#' vector with entries corresponding to the run test statistics for runs of
#' length p for each set of binary chains of data.
#'
#' @param binChains A three dimensional integer vector containing sets of
#' chains of binary data.
#' @param p An integer representing the length of run to test for.
#' @export
#' @useDynLib maRkov
multipleRunTestStatArray <- function(binChains, p) {
    .Call('maRkov_multipleRunTestStatArray', PACKAGE = 'maRkov', binChains, p)
}

#' Swap elements of single binary chains
#'
#' \code{swap} is used to swap elements of a single binary chain if doing so
#' maintains the same number of transitions between the two states of that
#' chain.
#'
#' \code{swap} takes a R integer vector, as well as two integers, i and j,
#' which are valid indicies of that vector. It then checks if swapping the
#' values at indicies i and j would change the number of transitions between
#' states in the vector, and if the swap does not, it switches the two values,
#' returning a new vector with the values switched. If it cannot switch the
#' values, it returns the original vector.
#'
#' @param binChain A binary one dimensional integer vector.
#' @param i An integer which is a valid indice of the vector binChain.
#' @param j An integer which is a valid indice of the vector binChain.
swap <- function(binChain, m) {
    .Call('maRkov_swap', PACKAGE = 'maRkov', binChain, m)
}

#' Generate independent data from a single binary chain.
#'
#' \code{metropolis} takes a single binary chain of data in the form of an
#' integer vector and generates \code{b} new independent chains of data,
#' placing all of them in an integer matrix with the original data in the first
#' row.
#'
#' \code{metropolis} works by taking the supplied \code{binChain}, and
#' attempting \code{m} swaps on it, only preforming a swap of elements if
#' doing so maintains the number of transitions between states in the resulting
#' chain. \code{metropolis} then takes the resulting chain, and attempts
#' \code{m} swaps on it again, then saving the resulting vector in a new row
#' of an output matrix. \code{metropolis} does this \code{b} times, each time
#' saving the resulting vector. Once all of the new data has been generated,
#' \code{metropolis} returns the newly built integer matrix, of which the first
#' row is the original chain of data \code{binChain}.
#'
#' @param binChain A single binary chain of data represented by an integer
#' vector.
#' @param m An integer representing the number of swaps to be attempted.
#' @param b An integer representing the number of new chains of data to be
#' generated.
#' @export
#' @useDynLib maRkov
metropolis <- function(binChain, m, b) {
    .Call('maRkov_metropolis', PACKAGE = 'maRkov', binChain, m, b)
}

#' Second order transition counts for a single binary chain.
#'
#' \code{nCounts} counts the number of second order transitions in a binary
#' chain of data, then returns a three dimensional vector whose indicies
#' represent the type of transition, and whose values represent the number of
#' times that each transition occurs in the chain.
#'
#' @param binChain An integer vector representing a chain of data.
#' @param nChainUniques The number or unique values in the chain
#' \code{binChains}, represented as an integer value.
#' @export
#' @useDynLib maRkov
nCounts <- function(binChain, nChainUniques) {
    .Call('maRkov_nCounts', PACKAGE = 'maRkov', binChain, nChainUniques)
}

#' Calculates the liklihood ratio test statistic for a single binary chain.
#'
#' \code{u1TestStat} takes a binary chain of data and calculates the liklihood
#' ratio test statistic associated with it.
#'
#' @param binChain A binary chain of data in the form of a one dimensional
#' integer vector.
#' @param nChainUniques A integer value representing the number of unique
#' values in \code{binChain}.
u1TestStat <- function(binChain, nChainUniques) {
    .Call('maRkov_u1TestStat', PACKAGE = 'maRkov', binChain, nChainUniques)
}

#' Calculates the Pearson's chi square test statistic for a single binary chain
#' .
#'
#' \code{chiSqTestStat} takes a binary chain of data and calculates the
#' Pearson's chi square test statistic associated with it.
#'
#' @param binChain A single binary chain of data in the form of an integer
#' vector.
#' @param nChainUniques A integer value representing the number of unique
#' values in \code{binChain}.
chiSqTestStat <- function(binChain, nChainUniques) {
    .Call('maRkov_chiSqTestStat', PACKAGE = 'maRkov', binChain, nChainUniques)
}

#' Indicate whether or not there is a run at a point in a integer vector.
#'
#' \code{indicateRun} takes an integer vector \code{binChain}, and two
#' integers, \code{p} and \code{i}, and tells the user if a run of length
#' \code{p} starting and index \code{i} in the form of a boolean value.
#'
#' @param binChain A binary chain of data in the form of an integer vector.
#' @param p A integer value representing the length of the run to test for.
#' @param i A integer value representing the location in \code{binChain} to
#' test for a run starting at.
#' @export
#' @useDynLib maRkov
indicateRun <- function(binChain, p, i) {
    .Call('maRkov_indicateRun', PACKAGE = 'maRkov', binChain, p, i)
}

#' Calculate the run test statistic for a single binary chain.
#'
#' \code{runTestStat} takes an integer vector \code{binChain} of a chain of
#' binary data, and a integer \code{p} representing the length of run to test
#' for. It returns the run test stat for that chain of data.
#'
#' @param binChain A binary chain of data in the form of an integer vector.
#' @param p An integer greater than one representing the length of run to test
#' for.
runTestStat <- function(binChain, p) {
    .Call('maRkov_runTestStat', PACKAGE = 'maRkov', binChain, p)
}

#' Calulate likihood ratio test statistics for many binary chains.
#'
#' \code{u1TestStatArray} takes an integer matrix with each row denoting a
#' binary chain of data and returns an integer vector with liklihood ratio test
#' statistics corresponding to each binary chain.
#'
#' @param binChains A two dimensional integer matrix with each row denoting a
#' individual binary chain of data.
#' @param nChainUniques An integer value representing the number of unique
#' values in the binary chains found in \code{binChains}.
u1TestStatArray <- function(binChains, nChainUniques) {
    .Call('maRkov_u1TestStatArray', PACKAGE = 'maRkov', binChains, nChainUniques)
}

#' Calculate the chi square test statistics for many single binary chains.
#'
#' \code{chiSqTestStatArray} takes a two dimensional matrix of many binary
#' chains of data and returns a numberic vector filled with a chi square test
#' statistic for each of them.
#'
#' @param binChains A integer matrix of binary chains of data, with each row
#' being a different chain.
#' @param nChainUniques A integer value representing the number of unique
#' values in \code{binChains}.
chiSqTestStatArray <- function(binChains, nChainUniques) {
    .Call('maRkov_chiSqTestStatArray', PACKAGE = 'maRkov', binChains, nChainUniques)
}

#' Calculate run test statistics for many binary chains.
#'
#' \code{runTestStatArray} takes an integer matrix with each row denoting a
#' binary chain of data and returns an integer vector with run test statistics
#' for runs of length \code{p} corresponding to each binary chain.
#'
#' @param binChains A two dimensional integer matrix with each row denoting a
#' individual binary chain of data.
#' @param p An integer value representing the length of run to test for.
#' @export
#' @useDynLib maRkov
runTestStatArray <- function(binChains, p) {
    .Call('maRkov_runTestStatArray', PACKAGE = 'maRkov', binChains, p)
}

