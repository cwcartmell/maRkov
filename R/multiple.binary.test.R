#' Preform goodness-of-fit tests on multiple binary chains.
#'
#' \code{multiple.binary.test} is used to preform goodness-of-fit tests on
#' multiple binary chains of data of the same length to see if a Markov chain
#' model is appropriate.
#'
#' \code{multiple.binary.test} works by taking the supplied \code{binary.chains}
#' parameter, counting the transitions between diffferent elements, and then
#' generating \code{n} new sets of chains with the same number of transitions.
#' It generates these new sets of chains by attempting to swap random elements
#' of the chains \code{swaps} times, only doing so if the attempted swap
#' preserves the number of transitions between the two unique elements of the
#' chains. \code{multiple.binary.test} then saves the chain generated by this
#' process, then preforms a number of swaps equivalent to the value of
#' \code{swaps} on that chain again, then recording the result in a new entry in
#' a list of data. \code{multiple.binary.test} does this \code{n} times to
#' generate the \code{n} new sets of chains. These new sets of chains are
#' effictively independent of the original one.
#'
#' Once \code{multiple.binary.test} has generated new data, it preforms various
#' tests of that data. included in the function are the liklihood ratio test,
#' the Pearson's chi square test, and a run test for a run of length specified
#' by the argument \code{run}.
#'
#' @param binary.chains A two dimensional matrix, in which there are two unique
#' values.
#' @param swaps A positive nonzero integer value for the number of swaps to be
#' attempted on the chain. Larger values will tend to yeild "more independent"
#' data. Generally, the number of swaps should be much larger then the number of
#' elements in the matrix \code{binary.chains}.
#' @param n A positive nonzero integer representing the number of new sets of
#' chains to be generated.
#' @param run The length of the run to test for if one is interested in run
#' test statistics.
#' @param bins The number of bins to be displayed in histograms of test
#' statistics when one plots objects generated by \code{multiple.binary.test}.
#'
#' @examples
#' data <- matrix(data = c(0,0,1,1,0,0,1,0,1,1,
#'                         1,1,1,0,1,1,0,0,0,0,
#'                         1,1,0,0,0,1,1,0,0,1,
#'                         1,1,1,1,0,1,1,1,1,1,
#'                         1,1,0,1,1,1,0,0,1,0), ncol = 10, byrow = TRUE)
#' foo <- multiple.binary.test(binary.chains = data, swaps = 10000, n=10000,
#'                             run = 3, bins = 50)
#'
#' @return  \code{multiple.binary.test} returns a list of \link{class}
#' \code{"multiple.binary.test"} with the following elements:
#'
#' \code{data}, a list of matricies, the first of which is binary.chains, and
#' the rest of which are the generated data.
#'
#' \code{test.stats.lrt}, vector of liklihood ratio test statistics for each
#' element of list \code{data}.
#'
#' \code{test.stats.chisq}, a vector of Pearson's chi square test statistics
#' for each element of list \code{data}.
#'
#' \code{test.stats.run}, a vector of run test statistics for a run of length
#' \code{run} for each element of list \code{data}.
#'
#' \code{p.value.lrt}, the p-value of \code{binary.chain}, calculated exactly
#' from the distribution of \code{test.stats.lrt}.
#'
#' \code{p.value.chisq}, the p-value of \code{binary.chain}, calculated exactly
#' from the distribution of \code{test.stats.chisq}.
#'
#' \code{p.value.run}, the p-value of \code{binary.chain}, calculated exactly
#' from the distribution of \code{test.stats.run}.
#'
#' \code{call}, the function call.
#'
#' \code{bins}, the number of bins specified in the function call.
#'
#' \code{run}, the length of run specified in the function call.
#' @export
multiple.binary.test <- function(binary.chains, swaps = 1000, n = 1000,
                                 run = 4, bins = 30) {
    # Block checks binary chain, alters it if nessecary.

    if (check.false.binary.multiple(binary.chains) == FALSE) {
        print("Error: the argument binary.chain must be a set of binary data")
        return(NULL)
    }

    if (check.true.binary.multiple(binary.chains) == FALSE) {
        binary.chain <- alter.to.true.binary.multiple(binary.chain)
    }

    # End block.

    # Block generates data, p-values, returns list of all info with class
    # 'single.binary.test'.

    uniques <- c()
    for (i in 1:nrow(binary.chains)) {
        uniques <- union(uniques, unique(binary.chains[i, ]))
    }
    n.chain.uniques <- length(uniques)
    temp.data <- u6Metropolis(binary.chains, swaps, n)
    test.stats.lrt <- u6TestStatArray(temp.data, n.chain.uniques)
    test.stats.chisq <- multipleChiSqTestStatArray(temp.data, n.chain.uniques)
    test.stats.run <- multipleRunTestStatArray(temp.data, run)

    p.value.lrt <- vecGreaterThan(test.stats.lrt) / ( n + 1)
    p.value.chisq <- vecGreaterThan(test.stats.chisq) / ( n + 1)
    p.value.run <- vecGreaterThan(test.stats.run) / ( n + 1)

    out <- list(data = lapply(temp.data,
                             function(x) matrix(unlist(x),
                                                ncol = ncol(binary.chains),
                                                byrow = TRUE)),
               test.stats.lrt = test.stats.lrt,
               test.stats.chisq = test.stats.chisq,
               test.stats.run = test.stats.run,
               p.value.lrt = p.value.lrt,
               p.value.chisq = p.value.chisq,
               p.value.run = p.value.run,
               call = match.call(),
               bins = bins,
               run = run)

    class(out) <- "multiple.binary.test"

    return(out)

    # End block.
}
